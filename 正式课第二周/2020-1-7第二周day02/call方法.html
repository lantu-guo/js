<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /* 
        call、apply、bind 方法：他们是改变函数的this指向的
        他们是Function原型上的方法，
        而且每一个函数都是Function的实例，他们的__proto__都指向Function的原型
        所以每一函数都可以调用Function原型上的方法
        每一个函数都可以调用 call、apply、bind

        */
        //    function fn(){
        //        console.log(this)
        //    }
        //    let obj = {name:1};
        //    fn();

        //    obj.fn = fn;
        //    obj.fn();
        //    delete obj.fn
        //    console.log(obj)
        //-----------------------------------
        // function fn(n,m){
        //     console.log(this,n,m);
        // }
        // let obj = {name:1};
        // fn.call(55,1,2);
        /* 
        当前fn函数作为对象，找到当前所属类原型上的call方法，并且让call方法执行，
        在call方法执行的时候给他传递实参
        在call方法执行的时候，call内部执行了fn方法，并且让fn的this指向了call的第一个实参,然后call的实参从第二个开始就是fn执行时的实参
        */




        // function fn() {
        //     console.log(this)
        // }
        // let obj = { name: 1 };
        // fn = fn.bind(obj);
        // fn()


        /* 
      原型继承：继承公有和私有
      中间类继承：继承公有
      call继承：继承私有
      */
        function A() {
            this.a = 10;
        }

        function B() {
            /* 
            默认生成一个空对象(当前实例)
            让当前this指向这个对象(this就是当前实例)
            */
            // 构造函数里的this是当前实例
            this.s = 100;
            A.call(this); // 让A函数以普通函数身份运行，并且把A函数的this指向了当前类B的实例
        }
        let f1 = new B;
        console.log(f1)    //  B {s: 100, a: 10}

    </script>
</body>

</html>